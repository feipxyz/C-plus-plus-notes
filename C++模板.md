# C++模板 
 
@(c++基础)[c++, 模板]

模板是C++支持参数化多态的工具。  
- 模板是一种对类型进行参数化的工具；  
- 通常有两种形式：函数模板和类模板；  
- 函数模板针对仅参数类型不同的函数；  
- 类模板针对仅数据成员和成员函数类型不同的类。
  
使用模板的目的就是能够让程序员编写与类型无关的代码。

> 注意：模板的声明或定义只能在全局，命名空间或类范围内进行。即不能在局部范围，函数内进行，比如不能在main函数中声明或定义一个模板。

## 函数模板  
函数模板的格式：
```c++
template <class 形参名，class 形参名，......> 返回类型 函数名(参数列表)
{
　//函数体
}
```
> - `class`可以用`typename`代替，在这里`typenam`和`class`没区别.  
> - `<>`括号中的参数叫模板形参，模板形参不能为空。可以在该函数中使用内置类型的地方都可以使用模板形参名。一旦编译器确定了实际的模板实参类型就称他实例化了函数模板的一个实例。比如swap的模板函数形式为:  `template <class T> void swap(T& a, T& b){ }`
> - 对于函数模板而言不存在` h(int, int)` 这样的调用，**不能在函数调用的参数中指定模板形参的类型，对函数模板的调用应使用实参推演来进行**，即只能进行`h(2,3)` 这样的调用，或者`int a, b; h(a,b)`。

## 类模板

1. 类模板的格式为：  
```c++
template<class 形参名， class 形参名，…> class 类名
{ ... };
```  

- 可以在类中使用内置类型的地方都可以使用模板形参名来声明  
```cpp
template<class T> class A
{
public: T a; 
        T b; 
        T hy(T c, T &d);
}; 

A<int> m;
```

- 对于类模板，模板形参的类型必须在类名后的尖括号中明确指定，类模板形参不存在实参推演的问题。  

- 在类模板外部定义成员函数的方法为：
```c++  
template<模板形参列表> 函数返回类型 类名<模板形参名>::函数名(参数列表)
{
 //函数体
}
```
比如有两个模板形参T1，T2的类A中含有一个void h()函数，则定义该函数的语法为：
```c++
template<class T1, class T2> 
void A<T1,T2>::h()
{
	;
}
```
- 模板的声明或定义只能在全局，命名空间或类范围内进行。即不能在局部范围，函数内进行，比如不能在main函数中声明或定义一个模板。

## 模板形参  
> **有三种类型的模板形参：类型形参，非类型形参和模板形参**  

### 类型形参    
**类型模板形参**：    
类型形参由关见字`class`或`typename`后接说明符构成，如`template<class T> void h(T a){};`其中T就是一个类型形参，类型形参的名字由用户自已确定。模板形参表示的是一个未知的类型。模板类型形参可作为类型说明符用在模板中的任何地方，与内置类型说明符或类类型说明符的使用方式完全相同，即可以用于指定返回类型，变量声明等。
> - **针对函数模板，不能为同一个模板类型形参指定两种不同的类型**，比如`template<class T>void h(T a, T b){}`，语句调用`h(2, 3.2)`将出错，因为该语句给同一模板形参T指定了两种类型，第一个实参`2`把模板形参`T`指定为`int`，而第二个实参`3.2`把模板形参指定为`double`，两种类型的形参不一致，会出错。  
  
> - 针对于类模板，当我们声明类对象为：`A<int> a`，比如`template<class T>T g(T a, T b){}`，语句调用`a.g(2, 3.2)`在编译时不会出错，但会有警告，因为在声明类对象的时候已经将`T`转换为`int`类型，而第二个实参`3.2`把模板形参指定为`double`，在运行时，会对`3.2`进行强制类型转换为`3`。当我们声明类的对象为：`A<double> a`,此时就不会有上述的警告，因为从`int`到`double`是自动类型转换。

### 非类型形参  
非类型模板形参：**模板的非类型形参也就是内置类型形参**，如`template<class T, int a> class B{};`其中`int a`就是非类型的模板形参。  
> - 非类型形参在模板定义的内部是常量值，也就是说**非类型形参在模板的内部是常量。**
> - **非类型模板的形参只能是整型，指针和引用，像`double`，`String` 这样的类型是不允许的。但是`double &`，`double *`，对象的引用或指针是正确的**。
> - 调用非类型模板形参的实参必须是一个常量表达式，即他必须能在编译时计算出结果。
> - 注意：任何局部对象，局部变量，局部对象的地址，局部变量的地址都不是一个常量表达式，都不能用作非类型模板形参的实参。全局指针类型，全局变量，全局对象也不是一个常量表达式，不能用作非类型模板形参的实参。
> - 全局变量的地址或引用，全局对象的地址或引用const类型变量是常量表达式，可以用作非类型模板形参的实参。
> - sizeof表达式的结果是一个常量表达式，也能用作非类型模板形参的实参。
> - 当模板的形参是整型时调用该模板时的实参必须是整型的，且在编译期间是常量，比如template <class T, int a> class A{};如果有int b，这时A<int, b> m;将出错，因为b不是常量，如果const int b，这时A<int, b> m;就是正确的，因为这时b是常量。
> - 非类型形参一般不应用于函数模板中，比如有函数模板template<class T, int a> void h(T b){}，若使用h(2)调用会出现无法为非类型形参a推演出参数的错误，对这种模板函数可以用显示模板实参来解决，如用h<int, 3>(2)这样就把非类型形参a设置为整数3。显示模板实参在后面介绍。
> - 非类型模板形参的形参和实参间所允许的转换
> - 允许从数组到指针，从函数到指针的转换。如：template <int *a> class A{}; int b[1]; A<b> m;即数组到指针的转换
> - const修饰符的转换。如：template<const int *a> class A{}; int b; A<&b> m;   即从int *到const int *的转换。
> - 提升转换。如：template<int a> class A{}; const short b=2; A<b> m; 即从short到int 的提升转换
> - 整值转换。如：template<unsigned int a> class A{};   A<3> m; 即从int 到unsigned int的转换。
> - 常规转换。




